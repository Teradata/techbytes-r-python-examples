--------------------------------------------------------------------------------
-- The contents of this file are Teradata Public Content and have been released
-- to the Public Domain.
-- Tim Miller & Alexander Kolovos - April 2020 - v.1.1
-- Copyright (c) 2020 by Teradata
-- Licensed under BSD; see "license.txt" file in the bundle root folder.
--
--------------------------------------------------------------------------------
-- R and Python TechBytes Demo - Part 0: Analysis with SQL
-- ------------------------------------------------------------------------------
-- File: R_Py_TechBytes-Part_0-Demo.sql
-- ------------------------------------------------------------------------------
-- The R and Python TechBytes Demo comprises of 5 parts:
-- Part 1 consists of only a Powerpoint overview of R and Python in Vantage
-- Part 2 demonstrates the Teradata R package tdplyr for clients
-- Part 3 demonstrates the Teradata Python package teradataml for clients
-- Part 4 demonstrates using R in-nodes with the SCRIPT and ExecR Table Operators
-- Part 5 demonstrates using Python in-nodes with the SCRIPT Table Operator
--
-- The present Part 0 performs the same analyticsl tasks described in demo parts
-- 2 and 3 by using SQL, instead of employing R and Python, respectively.
--------------------------------------------------------------------------------
--
-- This TechBytes demo utilizes a use case to predict the propensity of a
-- financial services customer base to open a credit card account.
--
-- In Section 1, Various features will be generated by joining and aggregating
-- from 3 tables based tables (10K customers, 100K accounts, 1M+ transactions)
-- into an analytic data set.
--
--   a) Pull through the cust_id, income, age, years_with_bank, nbr_children
--      from the Customer table
--   b) Create a gender indicator variable (female_ind) from gender in the
--      Customer table
--   c) Create marital status indicator variables (single_ind, married_ind,
--      seperated_ind) from marital_status in the Customer table
--   d) Create location indicator variables (ca_resident, ny_resident,
--      tx_resident, il_resident, az_resident, oh_resident) from state_code in
--      Customer table
--   e) Create account indicator variables (ck_acct_ind, cc_acct_ind,
--      sv_acct_ind) from acct_type in the Account table
--   f) Create average balance variables (ck_avg_bal, cc_avg_bal, sv_avg_bal)
--      by taking the mean of the beginning_balance and ending_balance in the
--      Account table
--   g) Create average transaction amounts (ck_avg_tran_amt, cc_avg_tran_amt,
--      sv_avg_tran_amt) by taking the average of the principal_amt and
--      interest_amt in the Transactions table
--   h) Create quarterly transaction counts (q1_nbr_trans, q2_nbr_trans,
--      q3_nbr_trans, q4_nbr_trans) by taking the count of tran_id's based
--      upon tran_date in the Transactions table
--
-- In Section 2, we create an XGBoost model and a Decision Forest model on a
-- 60% sample of rows.
-- Furthermore, we test/score both models with the remaining 40%.
-- We conclude the present demo Part 0 with the following operations:
-- - Run decision forest evaluator to determine the most pertinent variables.
-- - Run confusion matrix on both scored data sets.
-- - Save the models so that they can be scored again in the future.
--
-- Note: Code executed successfully on a Vantage system that runs Advanced SQL
--       Engine database v.16.20.40.01.
--------------------------------------------------------------------------------
-- File Changelog
--  v.1.0     2019-10-29     First release
--  v.1.1     2020-04-02     Added change log; no code changes in present file
--------------------------------------------------------------------------------

-- Establish a connection to Teradata Vantage server. Before you execute the
-- following statement, replace the variables <HOSTNAME>, <UID>, and <PWD>
-- with the target Vantage system hostname, your database user ID, and
-- password, respectively. Also, specify a default database, if applicable.

logon <IPADDRESS>/<UID>,<PWD>;       /* Specify target machine, credentials.  */
DATABASE <DB>;                       /* Specify default database, if desired. */

-- Grab the customer demographic variables and create indicator variables
-- for gender, marital_status and state_code. Also, get the account information
-- equired for the aggregation and create indicator variables for acct_type.
-- Use the transaction information required for the aggregation and pull out
-- the quarter the transaction was made. Finally, pull everything together
-- into an analytic data set - Accounts and Transactions are LEFT OUTER joined
-- to Customer and all variables must be aggregated and rolled up by cust_id

CREATE TABLE ADS_SQL AS (
    SELECT
        T1.cust_id AS cust_id
        ,MIN(T1.income) AS tot_income
        ,MIN(T1.age) AS tot_age
        ,MIN(T1.years_with_bank) AS tot_cust_years
        ,MIN(T1.nbr_children) AS tot_children
        ,CASE WHEN MIN(T1.marital_status) = 1 THEN 1 ELSE 0 END AS single_ind
        ,CASE WHEN MIN(T1.gender) = 'F' THEN 1 ELSE 0 END AS female_ind
        ,CASE WHEN MIN(T1.marital_status) = 2 THEN 1 ELSE 0 END AS married_ind
        ,CASE WHEN MIN(T1.marital_status) = 3 THEN 1 ELSE 0 END AS seperated_ind
        ,MAX(CASE WHEN T1.state_code = 'CA' THEN 1 ELSE 0 END) AS ca_resident_ind
        ,MAX(CASE WHEN T1.state_code = 'NY' THEN 1 ELSE 0 END) AS ny_resident_ind
        ,MAX(CASE WHEN T1.state_code = 'TX' THEN 1 ELSE 0 END) AS tx_resident_ind
        ,MAX(CASE WHEN T1.state_code = 'IL' THEN 1 ELSE 0 END) AS il_resident_ind
        ,MAX(CASE WHEN T1.state_code = 'AZ' THEN 1 ELSE 0 END) AS az_resident_ind
        ,MAX(CASE WHEN T1.state_code = 'OH' THEN 1 ELSE 0 END) AS oh_resident_ind
        ,MAX(CASE WHEN T2.acct_type = 'CK' THEN 1 ELSE 0 END) AS ck_acct_ind
        ,MAX(CASE WHEN T2.acct_type = 'SV' THEN 1 ELSE 0 END) AS sv_acct_ind
        ,MAX(CASE WHEN T2.acct_type = 'CC' THEN 1 ELSE 0 END) AS cc_acct_ind
        ,AVG(CASE WHEN T2.acct_type = 'CK' THEN T2.starting_balance+T2.ending_balance ELSE 0 END) AS ck_avg_bal
        ,AVG(CASE WHEN T2.acct_type = 'SV' THEN T2.starting_balance+T2.ending_balance ELSE 0 END) AS sv_avg_bal
        ,AVG(CASE WHEN T2.acct_type = 'CC' THEN T2.starting_balance+T2.ending_balance ELSE 0 END) AS cc_avg_bal
        ,AVG(CASE WHEN T2.acct_type = 'CK' THEN T3.principal_amt+T3.interest_amt ELSE 0 END) AS ck_avg_tran_amt
        ,AVG(CASE WHEN T2.acct_type = 'SV' THEN T3.principal_amt+T3.interest_amt ELSE 0 END) AS sv_avg_tran_amt
        ,AVG(CASE WHEN T2.acct_type = 'CC' THEN T3.principal_amt+T3.interest_amt ELSE 0 END) AS cc_avg_tran_amt
        ,COUNT(CASE WHEN ((EXTRACT(MONTH FROM T3.tran_date) + 2) / 3) = 1 THEN T3.tran_id ELSE NULL END) AS q1_trans_cnt
        ,COUNT(CASE WHEN ((EXTRACT(MONTH FROM T3.tran_date) + 2) / 3) = 2 THEN T3.tran_id ELSE NULL END) AS q2_trans_cnt
        ,COUNT(CASE WHEN ((EXTRACT(MONTH FROM T3.tran_date) + 2) / 3) = 3 THEN T3.tran_id ELSE NULL END) AS q3_trans_cnt
        ,COUNT(CASE WHEN ((EXTRACT(MONTH FROM T3.tran_date) + 2) / 3) = 4 THEN T3.tran_id ELSE NULL END) AS q4_trans_cnt
    FROM Customer AS T1
    LEFT OUTER JOIN Accounts AS T2
    ON T1.cust_id = T2.cust_id
    LEFT OUTER JOIN Transactions AS T3
    ON T2.acct_nbr = T3.acct_nbr
    GROUP BY T1.cust_id
) WITH DATA
PRIMARY INDEX (cust_id);

CREATE TABLE ADS_Train_Test_SQL AS (
    SELECT cust_id
        ,tot_income
        ,tot_age
        ,tot_cust_years
        ,tot_children
        ,female_ind
        ,single_ind
        ,married_ind
        ,seperated_ind
        ,ca_resident_ind
        ,ny_resident_ind
        ,tx_resident_ind
        ,il_resident_ind
        ,az_resident_ind
        ,oh_resident_ind
        ,ck_acct_ind
        ,sv_acct_ind
        ,cc_acct_ind
        ,ck_avg_bal
        ,sv_avg_bal
        ,cc_avg_bal
        ,ck_avg_tran_amt
        ,sv_avg_tran_amt
        ,cc_avg_tran_amt
        ,q1_trans_cnt
        ,q2_trans_cnt
        ,q3_trans_cnt
        ,q4_trans_cnt
        ,SAMPLEID AS SAMPLE_ID
    FROM ADS_SQL SAMPLE .60, .40
) WITH DATA
PRIMARY INDEX (cust_id);

CREATE TABLE ADS_Train_SQL AS (
    SELECT *
    FROM ADS_Train_Test_SQL
    WHERE SAMPLE_ID = 1
) WITH DATA
PRIMARY INDEX (cust_id);

CREATE TABLE ADS_Test_SQL AS (
    SELECT *
    FROM ADS_Train_Test_SQL
    WHERE SAMPLE_ID = 2
) WITH DATA
PRIMARY INDEX (cust_id);

-- Train an XGBoost model to predict Credit Card account ownership based upon
-- all independent variables previously created.

SELECT * FROM XGBoost (
    ON ( SELECT *
         FROM ADS_Train_SQL ) AS InputTable
  	OUT TABLE OutputTable(tempXGBmodel)
  	USING
      	IdColumn('cust_id')
      	NumBoostedTrees('4')
      	LossFunction('binomial')
      	PredictionType('classification')
      	RegularizationLambda('1')
      	ShrinkageFactor('0.1')
      	IterNum('10')
      	MinNodeSize('1')
      	MaxDepth('10')
      	ResponseColumn('cc_acct_ind')
      	NumericInputs('tot_income','tot_age','tot_cust_years','tot_children','female_ind','single_ind','married_ind','seperated_ind','ca_resident_ind','ny_resident_ind','tx_resident_ind','il_resident_ind','az_resident_ind','oh_resident_ind','ck_acct_ind','sv_acct_ind','ck_avg_bal','sv_avg_bal','ck_avg_tran_amt','sv_avg_tran_amt')
) AS sqlmr;

-- Score the XGBoost model against the holdout and compare actuals to predicted

CREATE MULTISET TABLE XGBprediction AS (
    SELECT * FROM XGBoostPredict (
    	  ON ( SELECT *
             FROM ADS_Test_SQL ) AS "input"
      	PARTITION BY ANY
      	ON tempXGBmodel AS ModelTable
      	DIMENSION
      	ORDER BY "tree_id", "iter", "class_num"
      	USING
          	IdColumn('cust_id')
          	Accumulate('cc_acct_ind')
          	NumBoostedTrees('4')
    ) AS sqlmr
) WITH DATA;

-- Train a Random Forest model to predict the same thing so we can compare
-- and see what algorithm fit the data the best.

SELECT * FROM DecisionForest (
	  ON ( SELECT *
         FROM ADS_Train_SQL ) as InputTable
  	OUT TABLE OutputTable(tempDFmodel)
  	OUT TABLE MonitorTable(tempDFmonitor)
  	USING
      	TreeType('classification')
      	NumTrees('500')
      	MinNodeSize('1')
      	Variance('0')
      	MaxDepth('12')
      	Mtry('5')
      	MtrySeed('100')
      	Seed('100')
      	SequenceInputBy('InputTable:cust_id')
      	ResponseColumn('cc_acct_ind')
      	NumericInputs('tot_income','tot_age','tot_cust_years','tot_children','female_ind','single_ind','married_ind','seperated_ind','ca_resident_ind','ny_resident_ind','tx_resident_ind','il_resident_ind','az_resident_ind','oh_resident_ind','ck_acct_ind','sv_acct_ind','ck_avg_bal','sv_avg_bal','ck_avg_tran_amt','sv_avg_tran_amt')
) AS sqlmr;

-- Call td_decision_forest_evaluator to determine the most important
-- variables in the Decision Forest model

CREATE MULTISET TABLE DFevaluation AS (
    SELECT * FROM DecisionForestEvaluator (
    	  ON tempDFmodel as "input"
    	  PARTITION BY ANY
    	  USING
    	     NumLevels('5')
    ) AS sqlmr
) WITH DATA;

-- Score the Decision Forest model

CREATE MULTISET TABLE DFprediction AS (
    SELECT * FROM DecisionForestPredict (
    	  ON ( SELECT *
             FROM ADS_Test_SQL ) as "input"
      	PARTITION BY ANY
      	ON tempDFmodel as ModelTable
      	DIMENSION
      	USING
          	IdColumn('cust_id')
          	Accumulate('cc_acct_ind')
          	Detailed('FALSE')
    ) AS sqlmr
) WITH DATA;

-- Compare model performance via confusion matrix

SELECT * FROM ConfusionMatrix (
  	ON XGBprediction AS "input"
  	PARTITION BY 1
  	OUT TABLE CountTable(tempXGBcount)
  	OUT TABLE StatTable(tempXGBstat)
  	OUT TABLE AccuracyTable(tempXGBaccuracy)
  	USING
      	ObsColumn('cc_acct_ind')
      	PredictColumn(' prediction')
) AS sqlmr;

SELECT * FROM ConfusionMatrix (
	ON DFprediction as "input"
	PARTITION BY 1
	OUT TABLE CountTable(tempRFcount)
	OUT TABLE StatTable(tempRFstat)
	OUT TABLE AccuracyTable(tempRFaccuracy)
	USING
    	ObsColumn('cc_acct_ind')
    	PredictColumn(' prediction')
) AS sqlmr;

-- Cleanup
DROP TABLE tempXGBmodel;
DROP TABLE XGBprediction;

DROP TABLE tempDFmodel;
DROP TABLE tempDFmonitor;
DROP TABLE DFevaluation;
DROP TABLE DFprediction;

DROP TABLE tempXGBcount;
DROP TABLE tempXGBstat;
DROP TABLE tempXGBaccuracy;
DROP TABLE tempRFcount;
DROP TABLE tempRFstat;
DROP TABLE tempRFaccuracy;
